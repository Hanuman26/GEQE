import sysimport jsonimport tangeloimport osimport timefrom sets import Setdef binCoordinate(strCord, fBinSize):    return str(int(float(strCord)/fBinSize)*fBinSize)@tangelo.restfuldef get(filePath='./', fileAppOut='appliedScores.csv', maxOut = "-1", bBinByLatLon="false", bBinByDate="false", fBinSize=".005", bCountUniqueUser="false"):    ssName  = filePath + "scoreFiles/" + fileAppOut    retList = []    f = open(ssName, 'r')    nRet = 0    if bBinByLatLon == "false":        for line in f:            nums = line.split('\t')            try:                dItem = {                    'lat':nums[0],                     'lon':nums[1],                    'nUnique':1,                    'nTotal':1,                    'posts':[{                             'cap':nums[2],                              'sco':str((int(float(nums[3])*10000.)*1.)/10000.),                             'usr':nums[4]                    }]                }                retList.append(dItem)            except:                continue            nRet = nRet + 1            if nRet == int(maxOut):                break    elif bBinByLatLon == "true":        dBinned = {}        for line in f:            nums = line.split('\t')            try:                sLat = binCoordinate(nums[0],float(fBinSize))                sLon = binCoordinate(nums[1],float(fBinSize))                sSco = str((int(float(nums[3])*10000.)*1.)/10000.)                sBin = sLat+","+sLon                if sBin in dBinned:                    dBinned[sBin][2].append(nums[2])                    dBinned[sBin][3].append(sSco)                    dBinned[sBin][4].add(nums[4].strip("\n"))                    dBinned[sBin][5].append(nums[4].strip("\n"))                else:                    sUser = nums[4].strip("\n")                    dBinned[sBin] = [sLat, sLon, [nums[2]], [sSco], Set([sUser]), [sUser]]            except:                continue        lBinned = filter(lambda x: len(x[2])>1,dBinned.values())        if bCountUniqueUser == "false":            lBinned.sort(cmp=lambda x, y: cmp(len(x[2]),len(y[2])), reverse=True)        else:            lBinned = filter(lambda x: len(x[4]),lBinned)            lBinned.sort(cmp=lambda x, y: cmp(len(x[4]),len(y[4])), reverse=True)        for i in lBinned:            dItem = {}            dItem = {                'lat':i[0],                'lon':i[1],                'nUnique':len(i[4]),                'nTotal':len(i[3]),                'posts':[]            }            for j in range(len(i[2])):                dPost = {'cap':i[2][j], 'sco':i[3][j], 'usr':i[5][j]}                dItem['posts'].append(dPost)            retList.append(dItem)            nRet = nRet + 1            if nRet == int(maxOut):                break    f.close()        try:        dictName = filePath + "dictFiles/dict_" + fileAppOut        lWordScores = []        f2 = open(dictName,'r')        for line in f2:            lWordScores.append(line.split('\t'))        if len(lWordScores[0])==6:            lWordClean = map(lambda x: [x[0], x[2], x[4], str((1.*int(float(x[5])*10000.))/10000.)], lWordScores)            lWordSorted = sorted(lWordClean,key=lambda x: float(x[3]),reverse=True)            retDict["dic"] = lWordSorted        else:            lWordClean = map(lambda x: [x[0], int(x[1])], lWordScores)            retDict["dic"] = lWordClean        except:        retDict["dic"] = "No dictionary file"        retDict["total"] = nRet    retDict["sco"] = retList    return json.dumps(retDict)